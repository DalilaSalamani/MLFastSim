from dataclasses import dataclass

import numpy as np
from matplotlib import pyplot as plt
from scipy.stats import norm

from core.constants import N_CELLS_Z, N_CELLS_R, VALID_DIR, SIZE_Z, SIZE_R
from utils.observables import LongitudinalProfile, ProfileType, Profile, Energy

plt.rcParams.update({"font.size": 22})


@dataclass
class Plotter:
    """ An abstract class defining interface of all plotters.

    Do not use this class directly. Use ProfilePlotter or EnergyPlotter instead.

    Attributes:
        _particle_energy: An integer which is energy of the primary particle in GeV units.
        _particle_angle: An integer which is an angle of the primary particle in degrees.
        _geometry: A string which is a name of the calorimeter geometry (e.g. SiW, SciPb).

    """
    _particle_energy: int
    _particle_angle: int
    _geometry: str

    def plot_and_save(self):
        pass


# TODO add type
def _best_fit(data: np.ndarray, bins: np.ndarray):
    """ Finds estimated shape of Gaussian from parameters using Maximum Likelihood Estimation (MLE) method (default
    one).

    Args:
        data: A numpy array with values of observables from multiple events.
        bins: A numpy array specifying histogram bins.

    Returns:
        TODO

    """
    _, new_bins, _ = plt.hist(data, bins, density=1)
    assert (all(bins == new_bins))
    assert (all(bins == new_bins))
    print("Done. They're also the same!")
    mu, sigma = norm.fit(new_bins)
    best_fit_line = norm.pdf(new_bins, mu, sigma)
    # TODO does it really make sense to return bins?
    return best_fit_line, new_bins


@dataclass
class ProfilePlotter(Plotter):
    """ Plotter responsible for preparing plots of profiles and their first and second moments.

    Attributes:
        _full_simulation: A numpy array representing a profile of data generated by Geant4.
        _ml_simulation: A numpy array representing a profile of data generated by ML model.
        _plot_gaussian: A boolean. Decides whether first and second moment should be plotted as a histogram or
            a fitted gaussian.
        _profile_type: An enum. A profile can be either lateral or longitudinal.

    """
    _full_simulation: Profile
    _ml_simulation: Profile
    _plot_gaussian: bool = False

    def __post_init__(self):
        # Check if profiles are either both longitudinal or lateral.
        full_simulation_type = type(self._full_simulation)
        ml_generation_type = type(self._ml_simulation)
        assert full_simulation_type == ml_generation_type, "Both profiles within a ProfilePlotter must be the same " \
                                                           "type. "

        # Set an attribute with profile type.
        if full_simulation_type == LongitudinalProfile:
            self._profile_type = ProfileType.LONGITUDINAL
        else:
            self._profile_type = ProfileType.LATERAL

    def _plot_and_save_customizable_histogram(self, full_simulation: np.ndarray, ml_simulation: np.ndarray,
                                              bins: np.ndarray, xlabel: str, observable_name: str,
                                              hist_weight: bool = False,
                                              y_log_scale: bool = True) -> None:
        """ Prepares and saves a histogram for a given pair of observables.

        Args:
            full_simulation: A numpy array of observables coming from full simulation.
            ml_simulation: A numpy array of observables coming from ML simulation.
            bins: A numpy array specifying histogram bins.
            xlabel: A string. Name of x-axis on the plot.
            observable_name: A string. Name of plotted observable.
            hist_weight: A boolean. If set to True, full_simulation and ml_simulation will be used as histogram weight
                while x will be defined by the number of layers. Should be set to True only while plotting profiles not
                first or second moments.
            y_log_scale: A boolean. Used log scale on y-axis is set to True.

        Returns:
            None.

        """
        fig, axes = plt.subplots(2, 1, figsize=(15, 10), clear=True, sharex="all")

        if hist_weight:
            if self._profile_type == ProfileType.LONGITUDINAL:
                x = np.arange(N_CELLS_Z)
            else:
                x = np.arange(N_CELLS_R)

            energy_full_sim, _, _ = axes[0].hist(x=x, weights=full_simulation, label="FullSim", bins=bins, alpha=0.4)
            energy_ml_sim, _, _ = axes[0].hist(x=x, weights=ml_simulation, label="MLSim", bins=bins, alpha=0.4)
        else:
            energy_full_sim, _, _ = axes[0].hist(x=full_simulation, label="FullSim", bins=bins, alpha=0.4)
            energy_ml_sim, _, _ = axes[0].hist(x=ml_simulation, label="MLSim", bins=bins, alpha=0.4)

        if y_log_scale:
            axes[0].set_yscale("log")
        axes[0].legend(loc="upper right")
        axes[0].set_xlabel(xlabel)
        axes[0].set_ylabel("Energy [Mev]")
        axes[0].set_title(
            f" $e^-$ , {self._particle_energy} [GeV], {self._particle_angle}$^{{\circ}}$, {self._geometry} "
        )
        x = (bins[:-1] + bins[1:]) / 2
        ratio = np.divide(energy_ml_sim, energy_full_sim, out=np.ones_like(energy_ml_sim),
                          where=(energy_full_sim != 0))
        axes[1].plot(x, ratio, "-o")
        axes[1].set_xlabel(xlabel)
        axes[1].set_ylabel("MLSim/FullSim")
        axes[1].axhline(y=1, color="black")
        plt.savefig(
            f"{VALID_DIR}{observable_name}_Geo_{self._geometry}_E_{self._particle_energy}_" +
            f"Angle_{self._particle_angle}.png"
        )

    def _plot_and_save_customizable_gaussian(self, full_simulation: np.ndarray, ml_simulation: np.ndarray,
                                             bins: np.ndarray, xlabel: str, observable_name: str) -> None:
        """ Prepares and saves a gaussian fitted to a given pair of observables.

        Args:
            full_simulation: A numpy array of observables coming from full simulation.
            ml_simulation: A numpy array of observables coming from ML simulation.
            bins: A numpy array specifying fitted bins.
            xlabel: A string. Name of x-axis on the plot.
            observable_name: A string. Name of plotted observable.

        Returns:
            None.

        """
        best_fit_line_full_simulation, bins_full_simulation = _best_fit(full_simulation, bins)
        best_fit_line_ml_simulation, bins_ml_simulation = _best_fit(ml_simulation, bins)
        assert (all(bins == bins_ml_simulation))
        assert (all(bins == bins_full_simulation))
        print("Done. They're the same!")
        plt.plot(bins_full_simulation, best_fit_line_full_simulation, label="FullSim")
        plt.plot(bins_ml_simulation, best_fit_line_ml_simulation, label="MLSim")
        plt.xlabel(xlabel)
        plt.legend()
        plt.savefig(
            f"{VALID_DIR}{observable_name}_Geo_{self._geometry}_E_{self._particle_energy}_" +
            f"Angle_{self._particle_angle}.png"
        )

    def _plot_profile(self) -> None:
        """ Plots profile of an observable.

        Returns:
            None.

        """
        full_simulation_profile = self._full_simulation.calc_profile()
        ml_simulation_profile = self._ml_simulation.calc_profile()
        if self._profile_type == ProfileType.LONGITUDINAL:
            bins = np.linspace(0, N_CELLS_Z - 1, N_CELLS_Z)
            observable_name = "LongProf"
            xlabel = "Layer index"
        else:
            bins = np.linspace(0, N_CELLS_R - 1, N_CELLS_R)
            observable_name = "LatProf"
            xlabel = "R index"
        self._plot_and_save_customizable_histogram(
            full_simulation_profile, ml_simulation_profile, bins, xlabel, observable_name, hist_weight=True)

    def _plot_first_moment(self, plot_gaussian=False) -> None:
        """ Plots and saves a first moment of an observable's profile.

        Args:
            plot_gaussian: A boolean. Decides whether first and second moment should be plotted as a histogram or
            a fitted gaussian.

        Returns:
            None.

        """
        full_simulation_first_moment = self._full_simulation.calc_first_moment()
        ml_simulation_first_moment = self._ml_simulation.calc_first_moment()
        if self._profile_type == ProfileType.LONGITUDINAL:
            xlabel = "$<\lambda> [mm]$"
            observable_name = "LongFirstMoment"
            bins = np.linspace(0, 0.4 * N_CELLS_Z * SIZE_Z, 128)
        else:
            xlabel = "$<r> [mm]$"
            observable_name = "LatFirstMoment"
            bins = np.linspace(0, 0.75 * N_CELLS_R * SIZE_R, 128)

        if plot_gaussian:
            plotting_function = self._plot_and_save_customizable_gaussian
        else:
            plotting_function = self._plot_and_save_customizable_histogram
        plotting_function(full_simulation_first_moment, ml_simulation_first_moment, bins,
                          xlabel, observable_name)

    def _plot_second_moment(self, plot_gaussian=False) -> None:
        """ Plots and saves a second moment of an observable's profile.

        Args:
            plot_gaussian: A boolean. Decides whether first and second moment should be plotted as a histogram or
            a fitted gaussian.

        Returns:
            None.

        """
        full_simulation_second_moment = self._full_simulation.calc_second_moment()
        ml_simulation_second_moment = self._ml_simulation.calc_second_moment()
        if self._profile_type == ProfileType.LONGITUDINAL:
            xlabel = "$<\lambda^{2}> [mm^{2}]$"
            observable_name = "LongSecondMoment"
            bins = np.linspace(0, pow(N_CELLS_Z * SIZE_Z, 2) / 35., 128)
        else:
            xlabel = "$<r^{2}> [mm^{2}]$"
            observable_name = "LatSecondMoment"
            bins = np.linspace(0, pow(N_CELLS_R * SIZE_R, 2) / 8., 128)

        if plot_gaussian:
            plotting_function = self._plot_and_save_customizable_gaussian
        else:
            plotting_function = self._plot_and_save_customizable_histogram
        plotting_function(full_simulation_second_moment, ml_simulation_second_moment, bins,
                          xlabel, observable_name)

    def plot_and_save(self) -> None:
        """ Main plotting function.

        Calls private methods and prints the information about progress.

        Returns:
            None.

        """
        if self._profile_type == ProfileType.LONGITUDINAL:
            profile_type_name = "longitudinal"
        else:
            profile_type_name = "lateral"
        print(f"Plotting the {profile_type_name} profile...")
        self._plot_profile()
        print(f"Plotting the first moment of {profile_type_name} profile...")
        self._plot_first_moment(self._plot_gaussian)
        print(f"Plotting the second moment of {profile_type_name} profile...")
        self._plot_second_moment(self._plot_gaussian)


@dataclass
class EnergyPlotter(Plotter):
    """ Plotter responsible for preparing plots of profiles and their first and second moments.

    Attributes:
        _full_simulation: A numpy array representing a profile of data generated by Geant4.
        _ml_simulation: A numpy array representing a profile of data generated by ML model.

    """
    _full_simulation: Energy
    _ml_simulation: Energy

    def _plot_total_energy(self, y_log_scale=True) -> None:
        """ Plots and saves a histogram with total energy detected in an event.

        Args:
            y_log_scale: A boolean. Used log scale on y-axis is set to True.

        Returns:
            None.

        """
        full_simulation_total_energy = self._full_simulation.calc_total_energy()
        ml_simulation_total_energy = self._ml_simulation.calc_total_energy()

        plt.figure(figsize=(12, 8))
        bins = np.linspace(np.min(full_simulation_total_energy), np.max(ml_simulation_total_energy), 50)
        plt.hist(full_simulation_total_energy, histtype="step", label="FullSim", bins=bins, color="black")
        plt.hist(ml_simulation_total_energy, histtype="step", label="MLSim", bins=bins, color="red")
        plt.legend()
        if y_log_scale:
            plt.yscale("log")
        plt.xlabel("Energy [MeV]")
        plt.ylabel("# events")
        plt.savefig(f"{VALID_DIR}E_tot_Geo_{self._geometry}_E_{self._particle_energy}_Angle_{self._particle_angle}.png")

    def _plot_cell_energy(self) -> None:
        """ Plots and saves a histogram with number of detector's cells across whole
        calorimeter with particular energy detected.

        Returns:
            None.

        """
        full_simulation_cell_energy = self._full_simulation.calc_cell_energy()
        ml_simulation_cell_energy = self._ml_simulation.calc_cell_energy()

        log_full_simulation_cell_energy = np.log10(full_simulation_cell_energy,
                                                   out=np.zeros_like(full_simulation_cell_energy),
                                                   where=(full_simulation_cell_energy != 0))
        log_ml_simulation_cell_energy = np.log10(ml_simulation_cell_energy,
                                                 out=np.zeros_like(ml_simulation_cell_energy),
                                                 where=(ml_simulation_cell_energy != 0))
        plt.figure(figsize=(12, 8))
        bins = np.linspace(-4, 1, 1000)
        plt.hist(log_full_simulation_cell_energy, bins=bins, facecolor="b", histtype="step", label="FullSim")
        plt.hist(log_ml_simulation_cell_energy, bins=bins, facecolor="r", histtype="step", label="MLSim")
        plt.xlabel("log10(E/MeV)")
        plt.ylim(bottom=1)
        plt.yscale("log")
        plt.ylim(bottom=1)
        plt.ylabel("# entries")
        plt.grid(True)
        plt.legend()
        plt.savefig(
            f"{VALID_DIR}Cell_E_Dist_Log_Geo_{self._geometry}_E_{self._particle_energy}_Angle_{self._particle_angle}.png"
        )

    def _plot_energy_per_layer(self):
        """ Plots and saves N_CELLS_Z histograms with total energy detected in particular layers.

        Returns:
            None.

        """
        full_simulation_energy_per_layer = self._full_simulation.calc_energy_per_layer()
        ml_simulation_energy_per_layer = self._ml_simulation.calc_energy_per_layer()

        number_of_plots_in_row = 9
        number_of_plots_in_column = 5

        fig, ax = plt.subplots(number_of_plots_in_column, number_of_plots_in_row, figsize=(20, 20))

        for layer_nb in range(N_CELLS_Z):
            bins = np.linspace(0, np.max(full_simulation_energy_per_layer[layer_nb]), 15)

            i = layer_nb // number_of_plots_in_row
            j = layer_nb % number_of_plots_in_row

            ax[i][j].hist(full_simulation_energy_per_layer[:, layer_nb],
                          histtype="step",
                          label="FullSim",
                          bins=bins,
                          color="black")
            ax[i][j].hist(ml_simulation_energy_per_layer[:, layer_nb],
                          histtype="step",
                          label="MLSim",
                          bins=bins,
                          color="red")
            ax[i][j].set_title(f"Layer {layer_nb}", fontsize=12)

        plt.savefig(
            f"{VALID_DIR}E_Layer_Geo_{self._geometry}_E_{self._particle_energy}_Angle_{self._particle_angle}.png"
        )

    def plot_and_save(self):
        """ Main plotting function.

        Calls private methods and prints the information about progress.

        Returns:
            None.

        """
        print("Plotting total energy...")
        self._plot_total_energy()
        print("Plotting cell energy...")
        self._plot_cell_energy()
        print("Plotting energy per layer...")
        self._plot_energy_per_layer()
